/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file FrontierEvolver.ih
 * @author Tristan Roussillon (\c tristan.roussillon@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2012/03/01
 *
 * @brief Implementation of inline methods defined in FrontierEvolver.h
 *
 * This file is part of the DGtal library.
 */


#define WITHINFO

//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------


template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TPredicate>
inline
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>
::FrontierEvolver(const KSpace& aK, LImage& aI, DImage& aD, const Surfel& aS, 
		  const Functor& aF, const Predicate& aP, Partition* aPartitionPtr, 
		  const double& aW)
  : myKSpace( aK ), myLImage( aI ), myDImage( aD ), 
    myPointSet( SetFromImageSelector<DImage>::get( myDImage ) ), 
    mySurfel( aS ), myFunctor( aF ), myPointPred( aP ), 
    myPartitionPtr( aPartitionPtr), myW( aW ),
    myInnerLabel( myLImage( getInnerPoint( mySurfel ) ) ), 
    myOuterLabel( myLImage( getOuterPoint( mySurfel ) ) ), 
    mySurfelPred( myKSpace, myLImage, myInnerLabel, myOuterLabel ), 
    myFrontier( new Frontier ( myKSpace, mySurfelPred, 
			       SurfelAdjacency<KSpace::dimension>( true ), 
			       mySurfel ) )
{ 
  ASSERT( myFrontier ); 

  ASSERT( myW > 0 );   
  ASSERT( myW <= 1.0 ); 

  #ifdef WITHINFO
  trace.info() << "Labels: " << myInnerLabel << " (inner region)" 
	       << " and " << myOuterLabel << " (outer region) " 
	       << std::endl;  
  #endif
  ASSERT( myInnerLabel != myOuterLabel ); 
  ASSERT( myKSpace.sIsSurfel( mySurfel ) );
  ASSERT( mySurfelPred( mySurfel ) ); 
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TPredicate>
inline
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>
::~FrontierEvolver()
{
  delete( myFrontier ); 
}


template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TPredicate>
inline
double
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>
::update(const double& aT)
{
  ASSERT( myKSpace.sIsSurfel( mySurfel ) ); 
  ASSERT( mySurfelPred( mySurfel ) ); 
  ASSERT( myInnerLabel == myLImage( getInnerPoint( mySurfel ) ) );
  ASSERT( myOuterLabel == myLImage( getOuterPoint( mySurfel ) ) );  

  #ifdef WITHINFO
  trace.info() << std::endl; 
  trace.info() << "starting surfel: " << mySurfel << std::endl;  
  trace.info() << "between: " << myInnerLabel << " (inner region)" 
	       << " and " << myOuterLabel << " (outer region) " 
	       << std::endl;  
  #endif

  /// set of points that are candidate to the flip
  typedef std::vector<Point> Band;
  typedef typename Band::const_iterator BandIterator; 
  Band narrowBand; 
  init ( std::back_inserter( narrowBand ) ); 
  #ifdef WITHINFO
  trace.info() << narrowBand.size() << " closest points" << std::endl; 
  #endif

  /// velocity and zero-crossing time computation
  typedef std::pair<Point,double> PointTime; 
  typedef std::vector<PointTime> CandidateVector; 
  typedef typename CandidateVector::const_iterator CandidateIterator; 
  CandidateVector candidates; 
  
  typedef std::pair<Distance, Velocity> DistanceVelocity; 
  typedef std::vector<DistanceVelocity> DistanceVelocityVector;
  typedef typename DistanceVelocityVector::const_iterator DistanceVelocityIterator; 
  DistanceVelocityVector buffer; 

  for ( BandIterator 
	 it = narrowBand.begin(), 
	 itEnd = narrowBand.end(); 
       it != itEnd; ++it)
    {
      //point
      Point p = *it; 
      // distance
      Distance d = myDImage( p );
      // velocity
      Velocity v = myFunctor( p );
      // storing distance and velocity
      buffer.push_back( DistanceVelocity( d, v ) ); 
      // new candidate with its zero-crossing time
      if ( ( myLImage( p ) == myInnerLabel ) 
	   || (myLImage( p ) == myOuterLabel ) )
	{
	  if ( ( (d>0) && (v<0) ) 
	       || ( (d<=0) && (v>0) ) )
	    { //if opposite signs (and v != 0)
	      double t = - static_cast<double>( d ) / v;
	      ASSERT( t >= 0 ); 
	      candidates.push_back( PointTime( p, t ) ); 
	    }
	}
    }
  #ifdef WITHINFO
  trace.info() << candidates.size() << " candidates " << std::endl; 
  #endif

  /// time threshold
  double tmax = aT; 
  #ifdef WITHINFO
  trace.info() << "Time threshold: " << tmax << std::endl; 
  #endif

  if (candidates.begin() != candidates.end())
    { //if they are candidates

      /// ordering of the points according 
      /// to their zero-crossing time
      #ifdef WITHINFO
      trace.info() << "ordering..." << std::endl;
      #endif
 
      details::CompareSecondElement timeCompare; 
      std::sort( candidates.begin(), candidates.end(), timeCompare ); 

      #ifdef WITHINFO
      trace.info() << "Times ranging from " 
		   << candidates.begin()->second 
		   << " to " 
		   << candidates.rbegin()->second 
		   << std::endl; 
      #endif

      /// flip points one by one, in order,
      /// while possible
      std::set<Point> notSimplePoints; //points not flipped because not simple

      unsigned int nbFlips = 0; 
      Point p = Point::diagonal(0), plast = Point::diagonal(0);
      double t = 0.0, tlast = 0.0;
      bool go = true;
      for (CandidateIterator 
	     it = candidates.begin(), 
	     itEnd = candidates.end(); 
	   ( (it != itEnd)&&(go) ); ++it)
	{
	  plast = p; 
	  p = it->first;
	  tlast = t; 
	  t = it->second; 
	  if (t <= tmax)
	    { 
	      const Label label = myLImage(p); 
	      const Label oppositeLabel = 
		(label == myInnerLabel)?myOuterLabel:myInnerLabel; 
	      if ( myPointPred( p, oppositeLabel ) )
		{ /// flip
		  nbFlips++;
		  checkPartition( p ); 
                  #ifdef WITHINFO
		  trace.emphase() << p << " flipped into region " 
				  << oppositeLabel << std::endl;
		  #endif
		  myLImage.setValue( p, oppositeLabel ); 
		}
	      else 
		{
		  notSimplePoints.insert( p ); 
                  #ifdef WITHINFO
		  trace.emphase() << p << " is not a simple point!" << std::endl;
		  #endif
		}
	    }
	  else 
	    go = false; 
	}

      #ifdef WITHINFO
      trace.info() << nbFlips << " flipped points in " << tlast << " unit time" << std::endl; 
      #endif

      /// update distance map
      #ifdef WITHINFO
      trace.info() << "updating signed distance function..." << std::endl; 
      #endif

      if (tlast == 0.0) 
	tlast = tmax; 

      DistanceVelocityIterator itBuffer = buffer.begin(); 
      for (BandIterator 
	     it = narrowBand.begin(), 
	     itEnd = narrowBand.end(); 
	   it != itEnd; ++it, ++itBuffer)
	{
	  // velocity
	  DistanceVelocity pair( *itBuffer );  
	  Distance newDist = pair.first + tlast*pair.second; 

	  //label 
	  const Label pLabel = myLImage( *it ); 

	  const Distance eps = std::numeric_limits<Distance>::epsilon();
	  //const Distance eps = 0.00001; 
	  // correction due to the approximation error
	  if ( ( (newDist < 0.0001)&&(newDist > -0.0001) )
	  //correction due to the non simplicity
	       || ( notSimplePoints.find( *it ) != notSimplePoints.end() ) )
	    {
	      if (pLabel == myInnerLabel) newDist = -eps; 
	      else newDist = eps; 
	    }

	  #ifdef WITHINFO
	  if ( !( ( (newDist <= 0)&&(myLImage( *it ) == myInnerLabel) ) 
		  || ( (newDist > 0)&&(myLImage( *it ) == myOuterLabel) ) 
		  || ( (myLImage( *it ) != myInnerLabel)&&(myLImage( *it ) != myOuterLabel) ) ) )
	    {
	      trace.info() << *it << " in " << myLImage( *it ) 
			   << " at " << newDist << std::endl; 
	    }
	  #endif
	  ASSERT( ( (newDist <= 0)&&(myLImage( *it ) == myInnerLabel) ) 
		  || ( (newDist > 0)&&(myLImage( *it ) == myOuterLabel) ) 
		  || ( (myLImage( *it ) != myInnerLabel)&&(myLImage( *it ) != myOuterLabel) ) );

	  // set value
	  myDImage.setValue( *it, newDist );

	}

      /// update frontier if needed
      if (nbFlips > 0) 
	updateFrontier( plast ); 

      return tmax; 
    }
  else 
    return 0.0; 
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TPredicate>
template <typename TOutputIterator>
inline
void
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>
::init( const TOutputIterator& out )
{

  TOutputIterator res = out; 

  //predicate and FMM definitions
  typedef TwoLabelsPredicate<LImage, std::equal_to<Label> > LabelPredicate; 
  typedef CascadingPointPredicate< typename Domain::Predicate, 
    LabelPredicate > PointPredicate4FMM; 
  LabelPredicate predOnLabels( myLImage, myInnerLabel, myOuterLabel );
  PointPredicate4FMM pointPredicate( myLImage.domain().predicate(), predOnLabels );   
  typedef FMM<DImage, PointSet, PointPredicate4FMM > FMM;
  // typename Domain::Predicate pointPredicate = myDImage.domain().predicate(); 
  // typedef FMM<DImage, PointSet, typename Domain::Predicate> FMM; 

  /// initialization of the band from the 
  /// points adjacent to the frontier   
  if (myPointSet.size() == 0)
    {//first step
      FMM::initFromBelsRange(myKSpace, myFrontier->begin(), myFrontier->end(), 
			myDImage, myPointSet, 0.5, true); 
    }
  else 
    {//next steps

      //this renormalization doesn ot work at all
      // FMM::initFromBelsRange(myKSpace, myFrontier->begin(), myFrontier->end(), 
      // 			     myDImage, myDImage, myPointSet, true); 
      //TODO think about the best way of dealing with adjacentPoints
      //and copying it in the band
      typedef std::pair<const Point, Distance> PointDistance; 
      std::map<Point, Distance> adjacentPoints; 
      typedef typename std::map<Point, Distance>::iterator IteratorPointDistance; 

      for ( SurfelIterator it = myFrontier->begin(), 
      	      itEnd = myFrontier->end();
      	    it != itEnd; ++it )
      	{
      	  Point in( getInnerPoint( *it ) ); 
      	  Point out( getOuterPoint( *it ) );

	  ASSERT( myLImage(in) == myInnerLabel ); 
	  Distance din = myDImage( in ); 
	  ASSERT( din <= 0 ); 

	  ASSERT( myLImage(out) == myOuterLabel ); 
	  Distance dout = myDImage( out );
	  ASSERT( dout > 0 );

	  std::pair<IteratorPointDistance, bool> rin 
	    = adjacentPoints.insert( PointDistance( in, din ) );

	  std::pair<IteratorPointDistance, bool> rout 
	    = adjacentPoints.insert( PointDistance( out, dout ) );
      	}

      myPointSet.clear();
      for ( IteratorPointDistance 
      	      it = adjacentPoints.begin(), 
      	      itEnd = adjacentPoints.end();
      	    it != itEnd; ++it )
      	{
      	  PointDistance pair( *it ); 
      	  insertAndSetValue( myDImage, myPointSet, pair.first, pair.second );
      	}
    }


  std::copy( myPointSet.begin(), myPointSet.end(), res ); 

  #ifdef WITHINFO
  trace.info() << myPointSet.size() << " distinct adjacent points." << std::endl;  
  #endif


  /// FMM computation
  FMM fmm( myDImage, myPointSet, pointPredicate );
  #ifdef WITHINFO
  trace.info() << fmm << std::endl;  
  #endif

  Point p = Point::diagonal(0);      //last point
  Distance d = 0;                  //its distance
  //first pass
  {
    double threshold = std::max( std::abs(fmm.max()),std::abs(fmm.min()) ) 
      + 2.0;  // distance threshold
    while ( (fmm.computeOneStep( p, d )) 
	    && (std::abs(d) < threshold) )
      {
	ASSERT( myDImage(p) == d ); 
        #ifdef WITHINFO
	if (! ( ((myLImage(p) == myInnerLabel)&&(d<0.0001))
		|| ((myLImage(p) == myOuterLabel)&&(d>-0.0001)) 
		|| ( (myLImage(p) != myInnerLabel)&&(myLImage(p) != myOuterLabel) ) ) )
	  {
	    trace.info() << p << " in " << myLImage(p) << " at " << d << std::endl; 
	  } 
	#endif

	ASSERT( ((myLImage(p) == myInnerLabel)&&(d<0.0001))
		|| ((myLImage(p) == myOuterLabel)&&(d>-0.0001)) 
		|| ( (myLImage(p) != myInnerLabel)&&(myLImage(p) != myOuterLabel) ) ); 
	*res++ = p; 
      }
  }
  #ifdef WITHINFO
  trace.info() << fmm << std::endl;  
  #endif

  //second pass
  {
    double threshold = std::max( std::abs(fmm.max()),std::abs(fmm.min()) ) 
      + 2.0;  // distance threshold
    while ( (fmm.computeOneStep( p, d )) 
	    && (std::abs(d) < threshold) )
      { }
  }
  #ifdef WITHINFO
  trace.info() << fmm << std::endl;  
  #endif

}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TPredicate>
inline
typename DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>::Surfel
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>
::surfel() const
{
  return mySurfel;
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TPredicate>
inline
void
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>
::setSurfel(const Surfel& aSurfel)
{
  /// update surfel
  mySurfel = aSurfel;

  ASSERT( myKSpace.sIsSurfel( mySurfel ) ); 
  ASSERT( mySurfelPred( mySurfel ) ); 
  ASSERT( myInnerLabel == myLImage( getInnerPoint( mySurfel ) ) );
  ASSERT( myOuterLabel == myLImage( getOuterPoint( mySurfel ) ) );  

  /// update frontier
  delete ( myFrontier ); 
  myFrontier = new Frontier ( myKSpace, mySurfelPred, 
			      SurfelAdjacency<KSpace::dimension>( true ), 
			      mySurfel ); 
  ASSERT( myFrontier );   
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TPredicate>
inline
typename DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>
::SurfelIterator
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>
::begin() const
{
  return myFrontier->begin();
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TPredicate>
inline
typename DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>
::SurfelIterator
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>
::end() const
{
  return myFrontier->end();
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TPredicate>
inline
bool
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>
::isValid() const
{
  return ( ( myInnerLabel == myLImage( getInnerPoint( mySurfel ) ) )
	   && ( myOuterLabel == myLImage( getOuterPoint( mySurfel ) ) ) );   
}


template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
typename TFunctor, typename TPredicate>
inline
void
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>
::selfDisplay ( std::ostream & out ) const
{
  out << "[FrontierEvolver]\n";
  out << "\n";
}


template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TPredicate>
inline
typename DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, 
				TFunctor, TPredicate>::Point
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>
::getInnerPoint(const Surfel& s) const
{
  return myKSpace.sCoords( myKSpace.sDirectIncident( s, *myKSpace.sOrthDirs( s ) ) );
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TPredicate>
inline
typename DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, 
				TFunctor, TPredicate>::Point
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>
::getOuterPoint(const Surfel& s) const
{
  return myKSpace.sCoords( myKSpace.sIndirectIncident( s, *myKSpace.sOrthDirs( s ) ) ); 
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TPredicate>
inline
void
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>
::checkPartition(const Point& aPoint)
{
  if (myPartitionPtr != NULL)
    {
      myPartitionPtr->checkFrontiers( this, aPoint ); 
    }
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TPredicate>
inline
void
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>
::updateFrontier(const Point& p)
{
  /// spel creation
  typename KSpace::SCell spel; 
  const Label pLabel = myLImage(p); 
  if ( pLabel == myInnerLabel )
    {
      ASSERT( (myDImage(p) <= 0) ); 
      spel = myKSpace.sSpel( p, KSpace::POS ); 
    }
  else if ( pLabel == myOuterLabel )
    {
      ASSERT( (myDImage(p) > 0) ); 
      spel = myKSpace.sSpel( p, KSpace::NEG );
    }
  else 
    ASSERT( false && "impossible label in updateFrontier method" ); 

  /// for each direction 
  Surfel newSurfel; 
  bool flag = false; 
  for ( typename KSpace::DirIterator q = myKSpace.sDirs( spel ); 
  	( (q != 0)&&(!flag) ); ++q ) 
    { 
      const DGtal::Dimension dir = *q;

      /// for the direct orientation
      typename KSpace::SCell surfel 
  	= myKSpace.sDirectIncident( spel, dir );
      ASSERT( myKSpace.sIsSurfel( surfel ) ); 
      if ( mySurfelPred( surfel ) )
  	{
  	  newSurfel = surfel; 
  	  flag = true; 
  	}
      if (!flag)
  	{
  	  surfel = myKSpace.sIndirectIncident( spel, dir ); 
  	  ASSERT( myKSpace.sIsSurfel( surfel ) ); 
  	  if ( mySurfelPred( surfel ) )
  	    {
  	      newSurfel = surfel; 
  	      flag = true; 
  	    }
  	}
    } 
  ASSERT( flag && "last flipped point must be a border point in updateFrontier method" ); 

  this->setSurfel( newSurfel ); 

}

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TPredicate>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		    const FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, 
		    TFunctor, TPredicate> & object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


