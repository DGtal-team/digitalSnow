/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file FrontierEvolver2.ih
 * @author Tristan Roussillon (\c tristan.roussillon@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2012/03/01
 *
 * @brief Implementation of inline methods defined in FrontierEvolver2.h
 *
 * This file is part of the DGtal library.
 */


#define WITHINFO

//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------


template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
DGtal::FrontierEvolver2<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::FrontierEvolver2(const KSpace& aK, LImage& aI, DImage& aD, const Surfel& aS, 
		  const Functor& aF, const TopoPredicate& aP, Partition* aPartitionPtr )
  : myKSpace( aK ), myLImage( aI ), myDImage( aD ), 
    myPointSet( SetFromImageSelector<DImage>::get( myDImage ) ), 
    mySurfel( aS ), myFunctor( aF ), myTopoPred( aP ), 
    myPartitionPtr( aPartitionPtr),
    myInnerLabel( myLImage( getInnerPoint( mySurfel ) ) ), 
    myOuterLabel( myLImage( getOuterPoint( mySurfel ) ) ), 
    mySurfelPred( myKSpace, myLImage, myInnerLabel, myOuterLabel ), 
    myFrontier( new Frontier ( myKSpace, mySurfelPred, 
			       SurfelAdjacency<KSpace::dimension>( true ), 
			       mySurfel ) )
{ 
  ASSERT( myFrontier ); 

  #ifdef WITHINFO
  trace.info() << "Labels: " << myInnerLabel << " (inner region)" 
	       << " and " << myOuterLabel << " (outer region) " 
	       << std::endl;  
  #endif
  ASSERT( myInnerLabel != myOuterLabel ); 
  ASSERT( myKSpace.sIsSurfel( mySurfel ) );
  ASSERT( mySurfelPred( mySurfel ) ); 
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
DGtal::FrontierEvolver2<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::~FrontierEvolver2()
{
  delete( myFrontier ); 
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
typename DGtal::FrontierEvolver2<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>::Surfel
DGtal::FrontierEvolver2<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::surfel() const
{
  return mySurfel;
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
void
DGtal::FrontierEvolver2<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::setSurfel(const Surfel& aSurfel)
{
  /// update surfel
  mySurfel = aSurfel;

  ASSERT( myKSpace.sIsSurfel( mySurfel ) ); 
  ASSERT( mySurfelPred( mySurfel ) ); 
  ASSERT( myInnerLabel == myLImage( getInnerPoint( mySurfel ) ) );
  ASSERT( myOuterLabel == myLImage( getOuterPoint( mySurfel ) ) );  

  /// update frontier
  delete ( myFrontier ); 
  myFrontier = new Frontier ( myKSpace, mySurfelPred, 
			      SurfelAdjacency<KSpace::dimension>( true ), 
			      mySurfel ); 
  ASSERT( myFrontier );   
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
typename DGtal::FrontierEvolver2<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::SurfelIterator
DGtal::FrontierEvolver2<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::begin() const
{
  return myFrontier->begin();
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
typename DGtal::FrontierEvolver2<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::SurfelIterator
DGtal::FrontierEvolver2<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::end() const
{
  return myFrontier->end();
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
bool
DGtal::FrontierEvolver2<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::isValid() const
{
  return ( ( myInnerLabel == myLImage( getInnerPoint( mySurfel ) ) )
	   && ( myOuterLabel == myLImage( getOuterPoint( mySurfel ) ) ) );   
}


template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
typename TFunctor, typename TTopoPredicate>
inline
void
DGtal::FrontierEvolver2<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::selfDisplay ( std::ostream & out ) const
{
  out << "[FrontierEvolver2]\n";
  out << "\n";
}


///////////////////////////////////////////////////////////////////////////////
// ----------------------- Main methods ------------------------------


template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
double
DGtal::FrontierEvolver2<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::update(const double& aT)
{
  ASSERT( myKSpace.sIsSurfel( mySurfel ) ); 
  ASSERT( mySurfelPred( mySurfel ) ); 
  ASSERT( myInnerLabel == myLImage( getInnerPoint( mySurfel ) ) );
  ASSERT( myOuterLabel == myLImage( getOuterPoint( mySurfel ) ) );  

  #ifdef WITHINFO
  trace.info() << std::endl; 
  trace.info() << "starting surfel: " << mySurfel << std::endl;  
  trace.info() << "between: " << myInnerLabel << " (inner region)" 
	       << " and " << myOuterLabel << " (outer region) " 
	       << std::endl;  
  #endif

  /// narrow band
  typedef std::vector<Point> Band;
  Band narrowBand; 
  initNarrowBand ( std::back_inserter( narrowBand ) ); 
  #ifdef WITHINFO
  trace.info() << narrowBand.size() << " closest points" << std::endl; 
  #endif

  /// speed and zero-crossing time computation
  typedef std::vector<DistanceSpeed> DistanceSpeedVector;
  DistanceSpeedVector buffer; 
  /// candidates to flip
  typedef std::vector<PointTime> CandidateVector; 
  CandidateVector candidates; 
  initCandidates( narrowBand.begin(), narrowBand.end(), 
		  std::back_inserter( buffer ), 
		  std::back_inserter( candidates ) ); 
  ASSERT( narrowBand.size() == buffer.size() ); 
  ASSERT( narrowBand.size() >= candidates.size() ); 
  #ifdef WITHINFO
  trace.info() << candidates.size() << " candidates " << std::endl; 
  #endif

  if ( (narrowBand.size() != 0)&&(candidates.size() != 0) )
    { //if there are candidates

      /// ordering of the points according 
      /// to their zero-crossing time
      #ifdef WITHINFO
      trace.info() << "ordering..." << std::endl;
      #endif
 
      details::CompareSecondElement timeCompare; 
      std::sort( candidates.begin(), candidates.end(), timeCompare ); 

      #ifdef WITHINFO
      trace.info() << "Times ranging from " 
		   << candidates.begin()->second 
		   << " to " 
		   << candidates.rbegin()->second 
		   << std::endl; 
      #endif

      /// flip points one by one, in order, while it is possible
      //points not allowed to flip because not simple
      std::set<Point> forbiddenPoints; 
      // last point and its zero-crossing time
      Point lastP = Point::diagonal(0);
      double lastT = 0.0;
      int nbFlips = updateLabelImage( candidates.begin(), candidates.end(), 
				      std::inserter( forbiddenPoints, forbiddenPoints.begin() ), 
				      lastP, lastT, aT ); 
      ASSERT( lastT <= aT ); 
      #ifdef WITHINFO
      trace.info() << nbFlips << " flipped points in " << lastT << " unit time" << std::endl; 
      #endif

      /// update distance map anyway
      #ifdef WITHINFO
      trace.info() << "updating signed distance function..." << std::endl; 
      #endif
      updateDistanceImage( narrowBand.begin(), narrowBand.end(), 
			   buffer.begin(), forbiddenPoints, aT ); 
 
      return aT; 
    }
  else 
    return 0.0; 
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
template <typename TOutputIterator>
inline
void
DGtal::FrontierEvolver2<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::initNarrowBand( TOutputIterator res )
{

  //predicate and FMM definitions
  typedef TwoLabelsPredicate<LImage, std::equal_to<Label> > LabelPredicate; 
  typedef CascadingPointPredicate< typename Domain::Predicate, 
     LabelPredicate > PointPredicate4FMM; 
  LabelPredicate predOnLabels( myLImage, myInnerLabel, myOuterLabel );
   PointPredicate4FMM pointPredicate( myLImage.domain().predicate(), predOnLabels );   
   typedef FMM<DImage, PointSet, PointPredicate4FMM > FMM;
  // typename Domain::Predicate pointPredicate = myDImage.domain().predicate(); 
  // typedef FMM<DImage, PointSet, typename Domain::Predicate> FMM; 

  /// initialization of the band from the 
  /// points adjacent to the digital frontier   
  if (myPointSet.size() == 0)
    {//first step
      FMM::initFromBelsRange(myKSpace, myFrontier->begin(), myFrontier->end(), 
			myDImage, myPointSet, 0.5, true); 
    }
  else 
    {//next steps

      //TODO think about the best way of dealing with adjacentPoints
      //and copying it in the band
      typedef std::pair<const Point, Distance> PointDistance; 
      std::map<Point, Distance> adjacentPoints; 
      typedef typename std::map<Point, Distance>::iterator IteratorPointDistance; 

      for ( SurfelIterator it = myFrontier->begin(), 
      	      itEnd = myFrontier->end();
      	    it != itEnd; ++it )
      	{
      	  Point in( getInnerPoint( *it ) ); 
	  ASSERT( myLImage(in) == myInnerLabel ); 
	  Distance din = myDImage( in );
	  //arbitrary correction
	  if (din > 0) din = -0.5;
	  ASSERT( din <= 0 );
	  std::pair<IteratorPointDistance, bool> rin 
	    = adjacentPoints.insert( PointDistance( in, din ) );

      	  Point out( getOuterPoint( *it ) );
	  ASSERT( myLImage(out) == myOuterLabel ); 
	  Distance dout = myDImage( out );
	  //arbitrary correction 
	  	  if (dout <= 0) dout = 0.5; 
	  ASSERT( dout > 0 );
	  std::pair<IteratorPointDistance, bool> rout 
	    = adjacentPoints.insert( PointDistance( out, dout ) );
      	}

      myPointSet.clear();
      for ( IteratorPointDistance 
      	      it = adjacentPoints.begin(), 
      	      itEnd = adjacentPoints.end();
      	    it != itEnd; ++it )
      	{
      	  PointDistance pair( *it ); 
      	  insertAndSetValue( myDImage, myPointSet, pair.first, pair.second );
      	}
    }

  #ifdef WITHINFO
  trace.info() << myPointSet.size() << " distinct adjacent points." << std::endl;  
  if (myPointSet.size() <= 4) 
{
  std::copy( myPointSet.begin(), myPointSet.end(), ostream_iterator<Point>(std::cerr, ", ") ); 
}
  #endif

  
  /// FMM computation
  FMM fmm( myDImage, myPointSet, pointPredicate, 
	   myDImage.domain().size(), 3.0 );
  #ifdef WITHINFO
  trace.info() << fmm << std::endl;  
  #endif

  fmm.compute(); 

  #ifdef WITHINFO
  trace.info() << fmm << std::endl;  
  #endif
  
  std::copy( myPointSet.begin(), myPointSet.end(), res ); 
}


template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
template <typename TInputIterator, typename TOutputIterator1, typename TOutputIterator2>
inline
void
DGtal::FrontierEvolver2<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::initCandidates( const TInputIterator& itb, const TInputIterator& ite, 
		  TOutputIterator1 aDistanceSpeedIto, TOutputIterator2 aCandidateIto )
{

  /// computing speed
  typedef ImageContainerBySTLMap<Domain, double> SpeedImage; 
  SpeedImage speedImage( myDImage.domain(), 0.0 ); 

  for ( SurfelIterator it = myFrontier->begin(), 
	  itEnd = myFrontier->end();
	it != itEnd; ++it )
    {
      Point in( getInnerPoint( *it ) ); 
      ASSERT( myLImage(in) == myInnerLabel ); 
      speedImage.setValue( in, myFunctor( in ) );

      Point out( getOuterPoint( *it ) );
      ASSERT( myLImage(out) == myOuterLabel ); 
      speedImage.setValue( out, myFunctor( out ) );
    }
  #ifdef WITHINFO
  trace.info() << " speed of the adjacent points... " << std::endl;  
  #endif

  
  {/// extension speed
    typedef ImageContainerBySTLMap<Domain, double> TmpDImage; 
    TmpDImage tmpDImage( myDImage.domain(), 0.0 ); 
    typedef DigitalSetFromMap< ImageContainerBySTLMap<Domain, double> > TmpSet; 
    TmpSet tmpSet( tmpDImage );
    
    SpeedExtrapolator<TmpDImage, TmpSet, SpeedImage> 
      speedFunctor( tmpDImage, tmpSet, speedImage ); 

    typedef TwoLabelsPredicate<LImage, std::equal_to<Label> > LabelPredicate; 
    typedef CascadingPointPredicate< typename Domain::Predicate, 
      LabelPredicate > PointPredicate4FMM; 
    LabelPredicate predOnLabels( myLImage, myInnerLabel, myOuterLabel );
    PointPredicate4FMM pointPredicate( myLImage.domain().predicate(), predOnLabels );   
    typedef FMM<TmpDImage, TmpSet,  PointPredicate4FMM > FMM;
    FMM::initFromBelsRange( myKSpace, 
			    myFrontier->begin(), myFrontier->end(), 
			    myDImage, tmpDImage, tmpSet ); 

    //TODO point predicate must be derived from the narrow band
    FMM fmm( tmpDImage, tmpSet, pointPredicate, 
	     myDImage.domain().size(), 3.0 ); 
    Point lastPt = Point::diagonal(0);      //last point
    double lastDist = 0.0;                  //its distance
    while ( fmm.computeOneStep( lastPt, lastDist ) )
      { //new speed value
	speedImage.setValue( lastPt, speedFunctor( lastPt ) ); 
      }
  #ifdef WITHINFO
  trace.info() << " extension... " << std::endl;  
  #endif
  }

  /// candidates
  for ( TInputIterator it = itb; 
       it != ite; ++it)
    {
      // point
      Point p = *it; 
      // distance
      Distance d = myDImage( p );
      // speed
      Speed v = speedImage( p );
      // storing distance and speed
      *aDistanceSpeedIto++ = DistanceSpeed( d, v ); 
      // new candidate with its zero-crossing time
      if ( ( myLImage( p ) == myInnerLabel ) 
	   || (myLImage( p ) == myOuterLabel ) )
	{
	  if ( ( (d>0) && (v<0) ) 
	       || ( (d<=0) && (v>0) ) )
	    { // if opposite signs (and v != 0)
	      double t = - static_cast<double>( d ) / v;
	      ASSERT( t >= 0 ); 
	      // storing candidate
	      *aCandidateIto++ = PointTime( p, t ); 
	    }
	}
    }
}


template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
template <typename TInputIterator, typename TOutputIterator>
inline
int
DGtal::FrontierEvolver2<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::updateLabelImage( const TInputIterator& itb, const TInputIterator& ite, TOutputIterator ito, 
		    Point& aP, double& aT, const double&  aTMax )
{

  unsigned int nbFlips = 0; 

  for (TInputIterator it = itb;
       ( (it != ite)&&(it->second <= aTMax) ); ++it)
    {
      aP = it->first;
      aT = it->second; 
      const Label label = myLImage( aP ); 
      const Label oppositeLabel = 
	(label == myInnerLabel)?myOuterLabel:myInnerLabel;
 
      if ( myTopoPred( aP, oppositeLabel ) )
	{ /// flip
	  checkPartition( aP ); 
	  bool flagBefore = updateFrontier( aP );
	  myLImage.setValue( aP, oppositeLabel );
        #ifdef WITHINFO
	  trace.emphase() << aP << " flipped into region " 
			  << oppositeLabel << std::endl;
        #endif
	  if (!flagBefore)
	    {
	      bool flagAfter = retrieveFrontier( aP ); 
	      ASSERT( flagAfter && 
		      "flipped point must be a border point in updateFrontierAfter method" ); 
	    }
	  ++nbFlips;
	}
      else 
	{
	  *ito++ = aP; 
        #ifdef WITHINFO
	  trace.emphase() << aP << " is not a simple point!" << std::endl;
        #endif
	}
    }

  return nbFlips; 
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
bool
DGtal::FrontierEvolver2<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::retrieveFrontier(const Point& p)
{

#ifdef WITHINFO
  trace.info() << "updating frontier..." << std::endl;
#endif

  /// spel creation
  typename KSpace::SCell spel; 
  const Label pLabel = myLImage(p); 
  if ( pLabel == myInnerLabel )
      spel = myKSpace.sSpel( p, KSpace::POS ); 
  else 
      spel = myKSpace.sSpel( p, KSpace::NEG );

  /// for each direction 
  Surfel newSurfel; 
  bool flag = false; 
  for ( typename KSpace::DirIterator q = myKSpace.sDirs( spel ); 
  	( (q != 0)&&(!flag) ); ++q ) 
    { 
      const DGtal::Dimension dir = *q;

      /// for the direct orientation
      typename KSpace::SCell surfel 
  	= myKSpace.sDirectIncident( spel, dir );
      ASSERT( myKSpace.sIsSurfel( surfel ) ); 
      if ( mySurfelPred( surfel ) )
  	{
  	  newSurfel = surfel; 
  	  flag = true; 
  	}
      if (!flag)
  	{
  	  surfel = myKSpace.sIndirectIncident( spel, dir ); 
  	  ASSERT( myKSpace.sIsSurfel( surfel ) ); 
  	  if ( mySurfelPred( surfel ) )
  	    {
  	      newSurfel = surfel; 
  	      flag = true; 
  	    }
  	}
    } 
  if (flag) 
    {
      this->setSurfel( newSurfel ); 
      return true; 
    }
  else 
    return false; 
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
bool
DGtal::FrontierEvolver2<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::updateFrontier(const Point& p)
{

  const Surfel s = mySurfel; 
  if ( (getInnerPoint(s) == p)||(getOuterPoint(s) == p) )
    { /// if s is adjacent to p
      
      #ifdef WITHINFO
      trace.info() << "updating frontier..." << std::endl;
      #endif
      /// tracking until a new surfel is found
      bool flag = true;
      SurfelIterator it = myFrontier->begin(); 
      SurfelIterator itEnd = myFrontier->end(); 
      SCell newS;  
      while ( (it != itEnd)&&(flag) )
	{
	  newS = *it; 
	  if ( (getInnerPoint(newS) != p) && (getOuterPoint(newS) != p) )
	    {/// if newS is not adjacent to aPoint	  
	      flag = false; 
	    }
	  ++it; 
	}
      if (!flag) 
	{
	  setSurfel( newS );
          #ifdef WITHINFO
	  trace.info() << s << " moved to " << newS << std::endl;
          #endif
	  return true; 
	}
      else 
	return false; 
    }
  else 
    return true; 

}


template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
template <typename TInputIterator1, typename TInputIterator2, typename TSet>
inline
void
DGtal::FrontierEvolver2<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::updateDistanceImage( const TInputIterator1& itb, const TInputIterator1& ite,
		       TInputIterator2 aDistanceSpeedIt, 
		       const TSet& aSet, const double& t )
{
  for (TInputIterator1 it = itb; 
       it != ite; ++it, ++aDistanceSpeedIt)
    {
      // point
      const Point p = *it; 
      // distance and speed
      const DistanceSpeed pair( *aDistanceSpeedIt );  
      Distance newDist = pair.first + t * pair.second; 

      //label 
      const Label pLabel = myLImage( p ); 

      const Distance eps = std::numeric_limits<Distance>::epsilon();
      // correction due to the approximation error
      if ( ( (newDist < 0.0001)&&(newDist > -0.0001) )
	   //correction due to the non simplicity
	   || ( aSet.find( p ) != aSet.end() ) )
	{
	  if (pLabel == myInnerLabel) newDist = -eps; 
	  else newDist = eps; 
	}

    #ifdef WITHINFO
      if ( !( ( (newDist <= 0)&&(myLImage( p ) == myInnerLabel) ) 
	      || ( (newDist > 0)&&(myLImage( p ) == myOuterLabel) ) 
	      || ( (myLImage( p ) != myInnerLabel)&&(myLImage( p ) != myOuterLabel) ) ) )
	{
	  trace.info() << p << " in " << myLImage( p ) 
		       << " at " << newDist << std::endl; 
	}
    #endif

      // ASSERT( ( (newDist <= 0)&&(myLImage( p ) == myInnerLabel) ) 
      // 	      || ( (newDist > 0)&&(myLImage( p ) == myOuterLabel) ) 
      // 	      || ( (myLImage( p ) != myInnerLabel)&&(myLImage( p ) != myOuterLabel) ) );


      // set value
      myDImage.setValue( p, newDist );

    }

}


///////////////////////////////////////////////////////////////////////////////
// ----------------------- Small Helpers ------------------------------
template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
void
DGtal::FrontierEvolver2<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::checkPartition(const Point& aPoint)
{
  if (myPartitionPtr != NULL)
    {
      myPartitionPtr->checkFrontiers( this, aPoint ); 
    }
}


template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
typename DGtal::FrontierEvolver2<TKSpace, TLabelImage, TDistanceImage, 
				TFunctor, TTopoPredicate>::Point
DGtal::FrontierEvolver2<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::getInnerPoint(const Surfel& s) const
{
  return myKSpace.sCoords( myKSpace.sDirectIncident( s, *myKSpace.sOrthDirs( s ) ) );
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
typename DGtal::FrontierEvolver2<TKSpace, TLabelImage, TDistanceImage, 
				TFunctor, TTopoPredicate>::Point
DGtal::FrontierEvolver2<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::getOuterPoint(const Surfel& s) const
{
  return myKSpace.sCoords( myKSpace.sIndirectIncident( s, *myKSpace.sOrthDirs( s ) ) ); 
}


///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		    const FrontierEvolver2<TKSpace, TLabelImage, TDistanceImage, 
		    TFunctor, TTopoPredicate> & object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


